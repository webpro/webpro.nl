---
published: 2022-08-19
modified: 2023-09-13
description:
  The more expensive it is to refactor or replace a component in the system, the
  more value it has to design an interface to abstract the implementation away.
image: ./connected-particles-in-abstract-style.webp
tags: value, abstraction, interface, refactoring, system, design, implementation
---

# The value of abstractions

In software systems, maintenance quickly becomes harder as more components are
added. When a component deteriorates, it should be possible to refactor or
replace it without having to change many other parts of the system.

Following this principle, each component needs a clear separation of concern
with a clear interface, and without leaky abstractions.

:::FIGURE

[![Connected particles in abstract style (AI-generated by OpenAI)][2]][1]

:::

## Minimize the cost of change

Over time, implementations and underlying dependencies will change, but the
interfaces should hardly change. Adhering to the [Interface Segregation
Principle][3] ensures that changes to a component's implementation have minimal
impact on other components in the system.

> An interface should be more dependent on the code that calls it than the code
> that implements it.

Let's take an example component "C" in our system. The deeper C is everywhere in
the system, the more often it is used, the more important its interface becomes.
It may help to ask ourselves questions like this about C:

- Is it hard to refactor without affecting other components?
- Is it hard to replace within the structure?
- Is it hard to replace its external dependencies?
- Is it hard to build the next feature with an alternative?

Answering "yes" means more coupling of other components towards C, and harder
maintenance of the project.

This may also indicate a leaky abstraction: C might expose too many details and
limitations of its underlying implementation.

There is value in adding the right abstraction for C.

> The more expensive it is to refactor or replace a component in the system, the
> more value it has to design an interface to abstract the implementation away.

The hard part is to figure out the granularity of the components, what
components in the system need an abstraction, and to design their interfaces.
Design and refactor until the answers are "no".

In general, large monolithic components with many responsibilities are harder to
replace than a more modular solution. On the other hand, lots of granularity can
lead to an over-engineered system with too many components and
interrelationships.

Although software design takes time, and needs refinement along the way, it pays
off in the long run as it reduces maintenance complexity and facilitates system
evolution.

## Enforce restrictions

Even great interfaces and abstractions may go unnoticed by other developers.
Depending on the environment and ecosystem, automated tooling might be available
to help with this. At the lower level (code and sometimes configuration),
linters can be very effective.

Examples of such linters include ESLint's [no-restricted-imports][4] and the
[@nrwl/nx/enforce-module-boundaries][5] rule.

They help to [enforce boundaries in Nx projects][6] and prevent direct imports
of underlying modules or dependencies, and suggest to use the provided
abstraction instead.

When properly configured, tools like this effectively encourage developers to
think about the system and its components, and aim for better solutions.

At higher levels of the system, a more manual and pragmatic approach will be
necessary.

## Further reading

Here are some other articles about related programming principles:

- [SOLID][7]
- [Leaky abstraction][8]
- [Separation of concerns][9]
- [The True Meaning of Technical Debt][10]

[1]: https://labs.openai.com/s/70yE39l7hYwZ0Ph8UAjxIGWJ
[2]: ./connected-particles-in-abstract-style.webp
[3]:
  https://github.com/webpro/programming-principles#interface-segregation-principle
[4]: https://eslint.org/docs/latest/rules/no-restricted-imports
[5]:
  https://nx.dev/packages/eslint-plugin-nx/documents/enforce-module-boundaries
[6]: https://nx.dev/core-features/enforce-project-boundaries
[7]: https://en.wikipedia.org/wiki/SOLID
[8]: https://en.wikipedia.org/wiki/Leaky_abstraction
[9]: https://en.wikipedia.org/wiki/Separation_of_concerns
[10]: https://refactoring.fm/p/the-true-meaning-of-technical-debt
